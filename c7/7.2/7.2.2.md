## 7.2.2 需要了解的方便的日志方法
&emsp;&emsp;除了前面所展示的方法之外，console对象还有用来整理日志使其更易读的方法、以特定的条件／形式输出日志的方法等。根据用途选择不同的方法，可以使使用了日志的调试更有效率。<br>
&emsp;&emsp;在这里，我们介绍一些主要的方法。

**●给日志创建分组**<br>
&emsp;&emsp;使用group／groupEnd方法，可以给从调用group方法开始到调用groupEnd方法结束之间的日志创建分组。有大量的日志时，以方法、循环等为单位整理日志，可以改善日志的可读性。group／groupEnd方法也可以相互嵌套。

**●语法 group／groupEnd方法**
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後7.42.05.png)
> label：标签字符串

&emsp;&emsp;例如下面是使用外侧的for循环将整体作为一组，使用内部的for循环创建各个子组的例子。

**●清单7-10 log_group.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後7.47.14.png)
> // 开始父循环  
> '上层分组'  
> // 开始子循环  
> '下层分组'  
> // 结束子循环  
> // 结束父循环  
> 上层分组  
> 下层分组0  
> 下层分组1  
> 下层分组2

**●生成有父子关系的分组**<br>
*但是，在Internet Explorer／Microsoft Edge中分组不能正常运行，所有的日志都扁平地显示。
##### 【373页】
&emsp;&emsp;另外，还有和group方法很相似的groupCollapsed方法。和group方法不同的地方是以折叠的状态输出分组（当然，也可以手动展开）。日志分组不断增加，或者是想要查看整体时，使用groupCollapsed方法可读性更好。<br>
&emsp;&emsp;下面时使用groupCollapsed方法替换清单7-10的粗体字后的结果。
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後8.03.13.png)
> 上层分组

**●使用groupCollapsed方法时分组是被折叠的**

**■计数特定的代码被执行了多少次**<br>
&emsp;&emsp;使用count方法可以将这行被调用了多少次输出到日志中。

**●语法 count方法**
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後8.08.10.png)
> label：标签字符串

&emsp;&emsp;下面是在循环中调用count方法的例子。
##### 【374页】
**●清单7-11 log_count.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後8.15.25.png)
**●查看「LOOP」标签被调用了多少次**

&emsp;&emsp;为了知道参数label被调用了多少次，以「标签：次数」的形式输出。即使是在不同的地方调用同一个标签的count方法也可以正常运行。<br>
&emsp;&emsp;虽然也可以省略参数label，但是请注意，这时如果在不同的地方调用count方法，将视为是不同的。下面，是将①、②改为「console.count();」（省略参数label）后的结果。我们可以看到②中的计数被重置了。
![image](../../images/c7/スクリーンショット&#32;2019-04-11&#32;午後8.32.01.png)
**●在不同的地方调用空标签的count方法后的结果**
##### 【375页】
&emsp;&emsp;但是，在Internet Explorer／Microsoft Edge中和设定标签时一样，在②中没有重置而是继续计数。

**■输出运行时的堆栈追踪 IE9**<br>
&emsp;&emsp;使用trace方法，可以输出实时的堆栈追踪。堆栈追踪是指表示到目前阶段所调用的方法（函数）的层级信息。<br>
&emsp;&emsp;像下面这样，在像「函数1中有别的函数2，函数2中有函数3……」这样多个函数互相关联运行时，可以更简单地查看相互间的关系。

**●清单7-12 log.trace.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.01.40.png)
**●追溯显示调用的顺序**

**■计算脚本的运行时间**<br>
&emsp;&emsp;使用timer／TimerEnd方法可以计算从调用timer方法开始到调用timerEnd方法之间的运行时间。

**●语法 timer／TimerEnd方法**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.06.30.png)
> label：标签字符串

##### 【376页】
&emsp;&emsp;因为参数label是用来识别定时器的字符串，所以timer／TimerEnd方必须相对应。定时器也可以一次执行多个动作。<br>
&emsp;&emsp;例如下面是计算从对话框显示到关闭之间的时间。

**●清单7-13 log_timer.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.27.22.png)
> '请确认。'  

**●显示关闭对话框时经过的时间**

**■当条件表达式为false时输出日志**<br>
&emsp;&emsp;使用assert方法可以在指定的表达式为false时输出日志。

**●语法 assert方法**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.32.16.png)
> exp：条件表达式  
> message：日志字符串

&emsp;&emsp;例如，在检查／警告给函数传递的不正确的值时，使用assert方法会很方便。

**●清单7-14 log_assert.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.37.27.png)
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前9.37.46.png)
> '参数radius必须是正数。'  
> Assertion failed:参数radius必须是正数。

**●传递不正确的参数时输出错误日志**
##### 【377页】
&emsp;&emsp;circle函数是根据参数radius（半径）计算圆的面积的函数。在这个例子中，参数radius必须是「数字，并且，是正数」。如果不符合这个条件，assert方法就会输出错误日志。

**■以更易读的形式输出对象**<br>
&emsp;&emsp;使用dir方法，可以以对人类易读的形式输出对象的内容。不过，光靠这点说明，可能很难理解和log方法的差异。<br>
&emsp;&emsp;例如，下面的代码都是输出同样的window对象的属性。
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前10.28.32.png)
**●都是输出window对象的属性**

&emsp;&emsp;在输出Element（元素）对象时可以看出两者的差异。我们来看下下面的示例。

**●清单7-15 log_dir.html（上）／log_dir.js（下）**
![image](../../images/c7/スクリーンショット&#32;2019-04-12&#32;午前10.32.01.png)
> JavaScript完全学习教程  
> WINGS项目  
> WINGS项目  

##### 【378页】
**●log方法和dir方法输出的差异**

&emsp;&emsp;请注意，log方法是以HTML的形式输出Element对象的，而dir方法是将其作为对象树输出的。
