## 7.5.2 连接异步处理 ES2015
&emsp;&emsp;不过，光靠目前为止的说明，可能很难感受到Promise对象的优点。在单个异步处理中，反而会觉得Promise对象更麻烦，写法更复杂。在连接多个异步处理时才能真正发挥Promise对象的价值。<br>
&emsp;&emsp;例如下面的例子在第一个asyncProcess函数成功之后执行第二个asyncProcess函数。

**●清单7-33 promise2.js**
![image](../../images/c7/スクリーンショット&#32;2019-04-18&#32;午前11.20.58.png)
![image](../../images/c7/スクリーンショット&#32;2019-04-18&#32;午前11.21.07.png)
> // 首次调用asyncProcess函数  
> '徳治郎'  
> // 首次执行成功之后，第2次执行asyncProcess函数  
> '任三朗'  
> 错误：  
> 输入值：徳治郎  
> 输入值：任三朗

##### 【414页】
&emsp;&emsp;要连接多个异步处理，需要在then方法中返回新的Promise对象。在这个例子中，在①中首次执行asyncProcess函数，在其成功回调函数中调用了第2个asyncProcess函数（②）。<br>
&emsp;&emsp;这样，就可以使用点运算符来罗列多个then方法。这就是为什么本章开头说「使用Promise对象，可以像同步处理一样书写异步处理」。这样记述，和嵌套很深的回调函数相比，更容易理解了。<br>
&emsp;&emsp;如果①中的asyncProcess函数的参数为空时，会得到下面这样的结果。
```
错误：输入值为空
```
&emsp;&emsp;跳过了首个成功回调函数，所以没有执行第2个then方法中的失败回调函数。像这样，不需要在每个then方法中定义失败回调函数，可以在必要的位置一起处理错误，这也是Promise的优点之一。<br>
&emsp;&emsp;顺便说一下，下面是①中有参数，②中没有参数调用asyncProcess函数的结果。
```
输入值：徳治郎  
错误：输入值为空
```
&emsp;&emsp;这次，首次的成功回调函数被执行了，之后，调用了第2个then方法中的失败回调函数。